package com.example.cveexplorer.controller;

import com.example.cveexplorer.CveRepository;
import com.example.cveexplorer.entity.Cve;
import com.example.cveexplorer.exception.CveNotFoundException;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import javax.validation.Valid;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@CrossOrigin
@RestController
public class CveExplorerController {

	private final CveRepository repository;

	CveExplorerController(CveRepository repository) {
		this.repository = repository;
	}

	/**
	 * Health check endpoint. Returns "UP!" on success.
	 */
	@GetMapping("/cve/health")
	String health() {
		return "UP!";
	}


	/**
	 * An opinionated endpoint that returns the latest 5 CVE's. A UI should poll this endpoint at
	 * set intervals to display the latest data.
	 *
	 * @return - latest 5 cve's
	 */
	@GetMapping("/cve/recent")
	List<Cve> recent() {
		return repository.findTop5ByOrderByPublishedDesc();
	}

	/**
	 * Search a cve description for a keyword. For example, search for the string "wordpress" to identify
	 * issues related to wordpress.
	 * <p>
	 * ROADMAP: support different sorting options, paging and different languages
	 *
	 * @param search - case insensitive search keyword
	 * @return - the latest 5 results
	 */
	@GetMapping("/cve/search")
	List<Cve> search(@RequestParam String search) {
		// when no search term is present, return an empty list
		if (StringUtils.isEmpty(search)) {
			return new ArrayList<>();
		}

		Pageable paging = PageRequest.of(0, 5, Sort.by(Sort.Direction.DESC, "published"));
		return repository.findByDescriptionContainingIgnoreCase(search, paging);
	}

	/**
	 * Create a new CVE and add to the database. This CVE is given a unique cveId (to prevent clashes with
	 * any other cveIds) and a source type of API.
	 *
	 * @param newCve - new cve data
	 * @return - created cve
	 */
	@ApiResponses(value = {@ApiResponse(responseCode = "201")})
	@PostMapping("/cve")
	public ResponseEntity<Cve> create(@Valid @RequestBody Cve newCve) {

		Date now = Date.from(Instant.now());
		newCve.setCveId(Cve.SOURCE_TYPE_API + "-" + UUID.randomUUID());
		newCve.setPublished(now);
		newCve.setModified(now);
		newCve.setSource(Cve.SOURCE_TYPE_API);
		Cve saved = repository.save(newCve);

		return new ResponseEntity<>(saved, HttpStatus.CREATED);
	}

	/**
	 * Return data for a given cveId. A 404 not found exception is thrown if the cve does not exist.
	 *
	 * @param cveId - unique cveId
	 * @return - the cve
	 */
	@GetMapping("/cve/{cveId}")
	Cve getOne(@PathVariable String cveId) {

		Optional<Cve> cve = repository.findByCveId(cveId);
		if (cve.isEmpty()) {
			throw new CveNotFoundException(cveId);
		}

		return cve.get();
	}

	/**
	 * Update or create a given cve.
	 * If the cve exists, update certain fields. If the CVE does not exist, create it.
	 *
	 * @param newCve - new cve data
	 * @param cveId  - the cve identifier
	 * @return - the updated or newly created cve
	 */
	@PutMapping("/cve/{cveId}")
	Cve putCve(@PathVariable String cveId, @Valid @RequestBody Cve newCve) {

		Cve toSave;

		Optional<Cve> cve = repository.findByCveId(cveId);
		if (cve.isPresent()) {
			toSave = cve.get();
			toSave.setDescription(newCve.getDescription());
			toSave.setSeverity(newCve.getSeverity());

		} else {
			toSave = newCve;
			toSave.setCveId(cveId);
			toSave.setPublished(Date.from(Instant.now()));
		}

		toSave.setModified(Date.from(Instant.now()));
		return repository.save(toSave);
	}

	/**
	 * Delete the cve identified by cveId. If the CVE does not exist, a 404 is given returned, otherwise a
	 * 200 success for deleting.
	 *
	 * @param cveId - cve identifier
	 */
	@DeleteMapping("/cve/{cveId}")
	void deleteCve(@PathVariable String cveId) {
		Optional<Cve> cve = repository.findByCveId(cveId);
		if (cve.isEmpty()) {
			throw new CveNotFoundException(cveId);
		}

		repository.deleteById(cve.get().getId());
	}
}
