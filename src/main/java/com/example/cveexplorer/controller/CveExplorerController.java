package com.example.cveexplorer.controller;

import com.example.cveexplorer.entity.Cve;
import com.example.cveexplorer.exception.CveNotFoundException;
import com.example.cveexplorer.repository.CveRepository;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import javax.validation.Valid;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@CrossOrigin
@RestController
public class CveExplorerController {

	private static final Logger LOG = LoggerFactory.getLogger(CveExplorerController.class);

	public static final String ENDPOINT_CVE_HEALTH = "/cve/health";
	public static final String ENDPOINT_CVE_RECENT = "/cve/recent";
	public static final String ENDPOINT_CVE_SEARCH = "/cve/search";
	public static final String ENDPOINT_CVE_POST = "/cve";
	public static final String ENDPOINT_CVE_RESOURCE = "/cve/{cveId}";

	private final CveRepository repository;

	CveExplorerController(CveRepository repository) {
		this.repository = repository;
	}

	/**
	 * Health check endpoint. Returns "UP!" on success.
	 */
	@GetMapping(value = ENDPOINT_CVE_HEALTH, produces = MediaType.TEXT_HTML_VALUE)
	@ApiResponses(value = {@ApiResponse(responseCode = "200", description = "Success")})
	String health() {
		return "UP!";
	}


	/**
	 * An opinionated endpoint that returns the latest 5 CVE's. A UI should poll this endpoint at
	 * set intervals to display the latest data.
	 *
	 * @return - latest 5 cve's
	 */
	@GetMapping(value = ENDPOINT_CVE_RECENT, produces = MediaType.APPLICATION_JSON_VALUE)
	@ApiResponses(value = {@ApiResponse(responseCode = "200", description = "Success")})
	ResponseEntity<List<Cve>> recent() {
		LOG.info("recent endpoint called");
		return new ResponseEntity<>(repository.findTop5ByOrderByPublishedDesc(), HttpStatus.OK);
	}

	/**
	 * Search a cve description for a keyword. For example, search for the string "wordpress" to identify
	 * issues related to wordpress.
	 * <p>
	 * ROADMAP: support different sorting options, paging and different languages
	 *
	 * @param search - case insensitive search keyword
	 * @return - the latest 5 results
	 */
	@GetMapping(value = ENDPOINT_CVE_SEARCH, produces = MediaType.APPLICATION_JSON_VALUE)
	@ApiResponses(value = {@ApiResponse(responseCode = "200", description = "Success")})
	ResponseEntity<List<Cve>> search(@RequestParam String search) {
		LOG.info("search endpoint called");

		// when no search term is present, return an empty list
		if (StringUtils.isEmpty(search)) {
			return new ResponseEntity<>(new ArrayList<>(), HttpStatus.OK);
		}

		Pageable paging = PageRequest.of(0, 5, Sort.by(Sort.Direction.DESC, "published"));
		return new ResponseEntity<>(repository.findByDescriptionContainingIgnoreCase(search, paging), HttpStatus.OK);
	}

	/**
	 * Create a new CVE and add to the database. This CVE is given a unique cveId (to prevent clashes with
	 * any other cveIds) and a source type of API.
	 *
	 * @param newCve - new cve data
	 * @return - created cve
	 */
	@PostMapping(value = ENDPOINT_CVE_POST, produces = MediaType.APPLICATION_JSON_VALUE)
	@ApiResponses(value = {@ApiResponse(responseCode = "201", description = "Created")})
	public ResponseEntity<Cve> create(@Valid @RequestBody Cve newCve) {
		LOG.info("create endpoint called");

		Date now = Date.from(Instant.now());
		newCve.setCveId(Cve.SOURCE_TYPE_API + "-" + UUID.randomUUID());
		newCve.setPublished(now);
		newCve.setModified(now);
		newCve.setSource(Cve.SOURCE_TYPE_API);
		Cve saved = repository.save(newCve);

		LOG.info("created cve: " + newCve.getCveId());
		return new ResponseEntity<>(saved, HttpStatus.CREATED);
	}

	/**
	 * Return data for a given cveId. A 404 not found exception is thrown if the cve does not exist.
	 *
	 * @param cveId - unique cveId
	 * @return - the cve
	 */
	@GetMapping(value = ENDPOINT_CVE_RESOURCE, produces = MediaType.APPLICATION_JSON_VALUE)
	@ApiResponses(value = {@ApiResponse(responseCode = "200", description = "Success"),
			@ApiResponse(responseCode = "404", description = "Not found")})
	ResponseEntity<Cve> getOne(@PathVariable String cveId) {
		LOG.info("get endpoint called");

		Optional<Cve> cve = repository.findByCveId(cveId);
		if (cve.isEmpty()) {
			throw new CveNotFoundException(cveId);
		}

		LOG.info("get cve: " + cve.get().getCveId());
		return new ResponseEntity<>(cve.get(), HttpStatus.OK);
	}

	/**
	 * Update or create a given cve.
	 * If the cve exists, update certain fields. If the CVE does not exist, create it.
	 *
	 * @param newCve - new cve data
	 * @param cveId  - the cve identifier
	 * @return - the updated or newly created cve
	 */
	@PutMapping(value = ENDPOINT_CVE_RESOURCE, produces = MediaType.APPLICATION_JSON_VALUE)
	@ApiResponses(value = {@ApiResponse(responseCode = "200", description = "Success"),
			@ApiResponse(responseCode = "201", description = "Created")})
	ResponseEntity<Cve> putCve(@PathVariable String cveId, @Valid @RequestBody Cve newCve) {
		LOG.info("put endpoint called");

		Cve toSave;
		HttpStatus responseStatus;

		Optional<Cve> cve = repository.findByCveId(cveId);
		if (cve.isPresent()) {
			toSave = cve.get();
			toSave.setDescription(newCve.getDescription());
			toSave.setSeverity(newCve.getSeverity());
			responseStatus = HttpStatus.OK;

		} else {
			toSave = newCve;
			toSave.setCveId(cveId);
			toSave.setPublished(Date.from(Instant.now()));
			responseStatus = HttpStatus.CREATED;
		}

		toSave.setModified(Date.from(Instant.now()));
		Cve saved = repository.save(toSave);

		LOG.info("put cve: " + saved.getCveId());
		return new ResponseEntity<>(saved, responseStatus);
	}

	/**
	 * Delete the cve identified by cveId. If the CVE does not exist, a 404 is given returned, otherwise a
	 * 200 success for deleting.
	 *
	 * @param cveId - cve identifier
	 */
	@ApiResponses(value = {@ApiResponse(responseCode = "200", description = "Success"),
			@ApiResponse(responseCode = "404", description = "Not found")})
	@DeleteMapping(ENDPOINT_CVE_RESOURCE)
	void deleteCve(@PathVariable String cveId) {
		LOG.info("delete endpoint called");

		Optional<Cve> cve = repository.findByCveId(cveId);
		if (cve.isEmpty()) {
			throw new CveNotFoundException(cveId);
		}

		repository.deleteById(cve.get().getId());
		LOG.info("deleted cve: " + cve.get().getCveId());
	}
}
